// Stub implementations for external dependencies
// This allows building libchiaki without OpenSSL/Jerasure/Opus/FFmpeg

#include <chiaki/common.h>
#include <chiaki/gkcrypt.h>
#include <chiaki/fec.h>
#include <chiaki/ecdh.h>
#include <chiaki/rpcrypt.h>
#include <string.h>
#include <stdlib.h>

// ========== Random (OpenSSL) ==========
CHIAKI_EXPORT ChiakiErrorCode chiaki_random_bytes_crypt(uint8_t *buf, size_t buf_size) {
    // Use arc4random for iOS/visionOS
    arc4random_buf(buf, buf_size);
    return CHIAKI_ERR_SUCCESS;
}

CHIAKI_EXPORT uint32_t chiaki_random_32() {
    return arc4random();
}

// ========== ECDH (OpenSSL) ==========
CHIAKI_EXPORT ChiakiErrorCode chiaki_ecdh_init(ChiakiECDH *ecdh) {
    memset(ecdh, 0, sizeof(ChiakiECDH));
    // Stub: generate fake public key
    chiaki_random_bytes_crypt(ecdh->local_pub_key, sizeof(ecdh->local_pub_key));
    return CHIAKI_ERR_SUCCESS;
}

CHIAKI_EXPORT void chiaki_ecdh_fini(ChiakiECDH *ecdh) {
    memset(ecdh, 0, sizeof(ChiakiECDH));
}

CHIAKI_EXPORT ChiakiErrorCode chiaki_ecdh_set_local_key(ChiakiECDH *ecdh, const uint8_t *private_key, size_t private_key_size, const uint8_t *public_key, size_t public_key_size) {
    (void)ecdh; (void)private_key; (void)private_key_size;
    if (public_key && public_key_size <= sizeof(ecdh->local_pub_key)) {
        memcpy(ecdh->local_pub_key, public_key, public_key_size);
    }
    return CHIAKI_ERR_SUCCESS;
}

CHIAKI_EXPORT ChiakiErrorCode chiaki_ecdh_derive_secret(ChiakiECDH *ecdh, uint8_t *secret_out, const uint8_t *remote_key, size_t remote_key_size, const uint8_t *handshake_key, const uint8_t *remote_sig, size_t remote_sig_size) {
    (void)ecdh; (void)remote_key; (void)remote_key_size; (void)handshake_key; (void)remote_sig; (void)remote_sig_size;
    // Stub: generate fake shared secret
    chiaki_random_bytes_crypt(secret_out, CHIAKI_ECDH_SECRET_SIZE);
    return CHIAKI_ERR_SUCCESS;
}

CHIAKI_EXPORT ChiakiErrorCode chiaki_ecdh_get_local_pub_key(ChiakiECDH *ecdh, uint8_t *key_out, size_t *key_out_size, const uint8_t *handshake_key, uint8_t *sig_out, size_t *sig_out_size) {
    (void)handshake_key;
    if (*key_out_size < sizeof(ecdh->local_pub_key)) return CHIAKI_ERR_BUF_TOO_SMALL;
    memcpy(key_out, ecdh->local_pub_key, sizeof(ecdh->local_pub_key));
    *key_out_size = sizeof(ecdh->local_pub_key);
    
    // Stub signature
    if (sig_out && sig_out_size && *sig_out_size >= 64) {
        memset(sig_out, 0, 64);
        *sig_out_size = 64;
    }
    return CHIAKI_ERR_SUCCESS;
}

// ========== RPCrypt (using CommonCrypto instead of OpenSSL) ==========
#include <chiaki/rpcrypt.h>
#include <CommonCrypto/CommonCrypto.h>
#include <CommonCrypto/CommonCryptor.h>

// PS5 tables and keys copied from rpcrypt.c
static const uint8_t ps5_keys_1[512] = {
    0x79,0x4d,0x78,0x30,0xfe,0x10,0x52,0x4c,0xa8,0x90,0x5b,0x9a,0x7e,0x5f,0xd3,0xe1,0x13,0xe0,0xf1,0x0f,0xa3,0xe7,0xbb,0x45,0x7f,0xdc,0x8e,0xd5,0xf1,0x04,0x5c,0x78,
    0x51,0xef,0xf8,0x65,0x59,0x03,0x39,0x84,0x37,0xae,0x59,0xdf,0x23,0xb6,0x60,0x34,0xe6,0x4b,0xe2,0xf5,0x4c,0x13,0xc6,0xda,0xf9,0xfd,0xb3,0x65,0x84,0xd6,0x45,0xec,
    0x2c,0x00,0xf2,0xed,0xdc,0xcb,0x93,0x6e,0x61,0x46,0xe5,0xd6,0x01,0x94,0xee,0x78,0x85,0x0e,0x68,0x5e,0xb5,0x5b,0xcd,0xd3,0x63,0x41,0xfc,0x81,0x43,0x1c,0x6f,0x7c,
    0xba,0xe8,0xbd,0x86,0x31,0xd5,0x70,0x7f,0xb5,0x4a,0x90,0x3e,0x84,0xe1,0x71,0xe0,0x02,0x99,0xf4,0x71,0xe7,0x02,0xed,0x36,0xaf,0xde,0x56,0xc2,0x90,0xe0,0xae,0xc2,
    0xf9,0xaf,0x53,0xc6,0xd8,0x62,0x16,0x32,0x27,0xfb,0x6e,0x9b,0x48,0xc6,0xea,0xff,0x6f,0x78,0x02,0x22,0x98,0x2c,0x1f,0xbf,0xb0,0x8e,0xa9,0x39,0xbc,0xdf,0x17,0xde,
    0xd7,0x0e,0xe1,0x7a,0x01,0x0e,0xc3,0x87,0xfc,0xaa,0xe4,0x6b,0x0f,0x5b,0x0a,0xf1,0x18,0x19,0x8a,0xe5,0x2c,0x36,0x9b,0x40,0x30,0x99,0x24,0x94,0x48,0xd7,0x47,0xb2,
    0xaf,0x6b,0x8c,0x40,0x9e,0x4d,0x6d,0x34,0x07,0xc1,0x26,0x2f,0xbb,0x14,0xf7,0xbc,0x36,0x52,0xbd,0x84,0xfe,0x4a,0x9a,0xf4,0x8a,0xdb,0x34,0x89,0xaa,0xf1,0x0d,0x94,
    0x0b,0x92,0xf4,0x1c,0xe4,0x6c,0x79,0x2d,0x6e,0xc0,0x19,0x0a,0xd5,0x55,0x94,0x14,0x05,0x13,0xc2,0x62,0x23,0xb3,0xd4,0x26,0xc4,0x44,0x56,0x7a,0xcd,0x1c,0xea,0xd4,
    0x74,0xb9,0x36,0x40,0x9f,0x08,0xfb,0x49,0x62,0x05,0x92,0x98,0xad,0x1d,0x9f,0x8a,0x76,0x8b,0xd4,0x0f,0x21,0x40,0x76,0xb6,0x16,0x91,0x45,0x93,0x66,0xcc,0x12,0xea,
    0x4d,0xf4,0x09,0xe2,0xac,0x33,0xd0,0x6f,0x43,0x51,0x07,0x3e,0xd7,0x95,0x2c,0x1e,0x1f,0x0c,0x24,0xb3,0x0e,0x3a,0xef,0x95,0xf5,0xeb,0x77,0xdd,0x20,0xf2,0x35,0x98,
    0xf2,0xae,0xa9,0x66,0xe6,0x13,0xef,0x5d,0x3a,0x2d,0x66,0xed,0xe2,0x1e,0xe9,0x32,0x4a,0x40,0xbf,0x37,0xc6,0x70,0x29,0xd9,0x8c,0xa1,0x61,0x4a,0x29,0x3d,0xc7,0x55,
    0x9c,0x94,0x9e,0xc9,0x11,0x45,0x10,0x28,0xa7,0x27,0xd1,0xd3,0xd0,0x84,0x79,0xc7,0xa9,0xb0,0xf6,0xaf,0x45,0x8c,0x3c,0xd4,0xdf,0x3b,0xf7,0x0d,0xa2,0x4f,0x13,0x97,
    0x78,0x27,0xf0,0x48,0xc0,0xa5,0xab,0x83,0x01,0x05,0xd0,0x12,0xd7,0x1e,0x12,0x3a,0x4e,0x98,0x77,0xae,0xba,0xb1,0x4e,0xb5,0x3b,0x59,0xca,0x6d,0xa5,0x11,0x80,0x91,
    0x9c,0x07,0x69,0x59,0x5a,0x53,0x70,0x7c,0x95,0x97,0x11,0x6d,0x66,0x8d,0xa3,0xbd,0xbb,0x2d,0xb0,0xbf,0x9b,0x10,0xcb,0xc7,0x0f,0x5b,0x7e,0x67,0xe2,0xb0,0x4b,0xba,
    0x10,0x12,0xb9,0xbc,0x97,0xfd,0x48,0xe4,0x8a,0xc1,0x0f,0xa1,0x30,0x9d,0x56,0x20,0x24,0x1a,0x7d,0x5b,0xa0,0xb4,0xbe,0x9d,0x38,0x4f,0xb4,0x56,0xa8,0x4d,0x13,0x7c,
    0x44,0xe8,0x84,0x97,0xeb,0x78,0x2c,0x52,0x85,0xe4,0xa2,0xf6,0xf3,0xd9,0x71,0x9e,0xee,0xb8,0x11,0x47,0xfb,0xa9,0x1b,0xc7,0x40,0xc6,0xe1,0x19,0x6d,0x50,0xa1,0x2a
};

static const uint8_t ps5_keys_0[512] = {
    0x24,0xd8,0xc2,0x69,0x4c,0x67,0x78,0x71,0xee,0x31,0xbd,0x2b,0x83,0xb2,0x1d,0x61,0xc9,0xa7,0x8e,0xed,0x9a,0xd3,0x6a,0x6b,0x5c,0xc8,0x35,0x79,0xa7,0x24,0xe2,0x17,
    0x06,0x60,0x2e,0xdf,0xf4,0xdb,0x27,0x10,0x55,0xd9,0xea,0x16,0x4e,0x90,0x0c,0xbf,0x40,0x6f,0x54,0xa5,0x31,0x70,0x2d,0x5d,0x1e,0x27,0xdf,0x37,0x40,0xba,0x9d,0x5d,
    0xff,0xe1,0x05,0x70,0x80,0xd4,0xb7,0xc2,0x96,0x7f,0x2f,0x42,0xeb,0x5a,0x08,0xde,0xc1,0xb5,0x52,0x15,0xf6,0xb5,0xf2,0xd9,0x69,0xa5,0xc7,0xc4,0x7f,0x46,0x64,0xa4,
    0xfd,0x46,0x98,0xa7,0xe1,0x2a,0x8e,0x6f,0xaf,0x65,0x42,0x28,0xb9,0xc2,0x6f,0x3e,0xe3,0xe4,0x4e,0xe4,0x5b,0x9d,0x60,0x10,0xb8,0x5a,0xb0,0x7d,0x04,0x0c,0x4c,0x24,
    0x78,0xbd,0xb8,0xba,0xdb,0x8f,0xe3,0xa0,0x75,0x6d,0x28,0xc2,0x33,0x5b,0x32,0x83,0xdd,0x51,0xb0,0xa5,0x8d,0x09,0x66,0xe4,0x5c,0xb8,0x70,0x0b,0xe6,0x82,0x14,0xb6,
    0xd2,0xb0,0xc2,0xe0,0x55,0xf3,0x84,0xad,0x9d,0x3a,0xf8,0x77,0xf5,0x9d,0x9a,0xa9,0x7d,0xf1,0x45,0x1b,0x9b,0x55,0x25,0xd8,0xc1,0xff,0x03,0xa5,0x48,0x0b,0x1b,0x19,
    0x0c,0xbd,0xe0,0xcd,0x48,0xf3,0x2c,0x99,0x19,0xd6,0xb8,0xbb,0xd6,0x35,0x43,0x6f,0x71,0xe3,0xef,0x3e,0x97,0xb8,0xe9,0x40,0xa8,0x47,0xe0,0xe0,0x01,0x16,0x9d,0xa7,
    0xe5,0x94,0x4b,0x1d,0xd2,0x80,0xa2,0x7f,0xf2,0x98,0x10,0x38,0x0d,0xb8,0x56,0xc3,0x7a,0x4b,0x4c,0x85,0xec,0x2f,0x23,0x89,0xaf,0xd5,0xba,0x9a,0xad,0xb0,0x61,0x9c,
    0x51,0xb4,0x6d,0x02,0x49,0x26,0xa4,0x34,0x84,0x20,0x35,0x30,0x23,0x0a,0x47,0x14,0x32,0x1a,0x96,0x0e,0xe8,0x0f,0x96,0x96,0xd4,0xba,0x68,0x3a,0x67,0x15,0x74,0xe0,
    0xd6,0x60,0x4c,0x68,0x50,0x73,0x14,0x2f,0x11,0x59,0xac,0xc8,0x32,0xd1,0xdb,0x4c,0x8a,0x94,0x75,0x33,0x61,0xd1,0xd4,0xfd,0xaa,0x6a,0x61,0x68,0xd8,0xae,0x31,0x4f,
    0xb8,0x07,0x7b,0x27,0x0f,0xf9,0x0b,0xb0,0xc2,0x64,0xb3,0x72,0xea,0x8b,0x87,0x40,0x09,0xb4,0x82,0xb4,0xad,0x76,0xf9,0x36,0x05,0x60,0x89,0xc8,0x20,0xeb,0xa5,0xf1,
    0x51,0x0b,0x27,0xa7,0xf0,0x76,0x84,0x96,0xeb,0xb1,0x2e,0xc2,0x85,0x28,0xbc,0x48,0x34,0xd4,0x01,0x8d,0x5b,0x25,0x54,0xe0,0xc4,0x4f,0xa0,0xfa,0x99,0x8d,0x6d,0x7a,
    0x64,0xb1,0xa9,0x5d,0xa4,0xf9,0xf5,0x22,0xeb,0x9a,0xf4,0xa8,0x7a,0x78,0x4b,0x7f,0xe2,0x8b,0x04,0x50,0x43,0x7d,0x26,0x2d,0x19,0x98,0x38,0x6a,0x4f,0x2d,0x30,0x15,
    0x2e,0x4f,0xcd,0xb9,0xce,0x9e,0x8d,0x12,0xc9,0xfe,0x33,0x8b,0x84,0xce,0x5b,0x40,0xe3,0x7f,0x72,0x6d,0x6c,0x8a,0x6a,0x9e,0x54,0xf1,0xe3,0x64,0x5d,0x6e,0x7f,0xac,
    0x1a,0xe7,0xf7,0xfa,0x00,0x22,0xed,0x2b,0x23,0xfa,0x58,0xc5,0xeb,0x44,0x92,0x5d,0xcc,0xaa,0x82,0x9f,0x23,0xfb,0xa6,0xc9,0x65,0x2a,0xe0,0x79,0x12,0x65,0x2c,0x34,
    0xc5,0x23,0x16,0xc9,0xcc,0x05,0x30,0xf3,0x96,0x0b,0x90,0x67,0x1a,0xa7,0x69,0x4c,0x3e,0x43,0x24,0x9d,0x4e,0x68,0xbd,0x8b,0x75,0x6e,0x9d,0x07,0x6f,0x1a,0x6a,0xba
};

static const uint8_t hmac_key_ps5[16] = { 0x46,0x46,0x87,0xb3,0x49,0xca,0x8c,0xe8,0x59,0xc5,0x27,0x0f,0x5d,0x7a,0x69,0xd6 };

static const uint8_t *rpcrypt_hmac_key(ChiakiRPCrypt *rpcrypt) {
    (void)rpcrypt; // Only PS5 used in this project currently
    return hmac_key_ps5;
}

CHIAKI_EXPORT void chiaki_rpcrypt_bright_ambassador(ChiakiTarget target, uint8_t *bright, uint8_t *ambassador, const uint8_t *nonce, const uint8_t *morning) {
    (void)target;
    // Use HMAC to derive keys from nonce and morning
    CCHmac(kCCHmacAlgSHA256, morning, 16, nonce, 16, bright);
    CCHmac(kCCHmacAlgSHA256, nonce, 16, morning, 16, ambassador);
}

CHIAKI_EXPORT void chiaki_rpcrypt_aeropause_ps4_pre10(uint8_t *aeropause, const uint8_t *ambassador) {
    // Not used for PS5
    memcpy(aeropause, ambassador, CHIAKI_RPCRYPT_KEY_SIZE);
}

CHIAKI_EXPORT ChiakiErrorCode chiaki_rpcrypt_aeropause(ChiakiTarget target, size_t key_1_off, uint8_t *aeropause, const uint8_t *ambassador) {
    if(target < CHIAKI_TARGET_PS4_10)
        return CHIAKI_ERR_INVALID_DATA;
    if(key_1_off >= 0x20)
        return CHIAKI_ERR_INVALID_DATA;
    // PS5 formula: aeropause[i] = (ambassador[i] ^ k) + (-0x2d) + i
    for(size_t i = 0; i < CHIAKI_RPCRYPT_KEY_SIZE; i++) {
        uint8_t k = ps5_keys_1[i*0x20 + key_1_off];
        aeropause[i] = (uint8_t)((ambassador[i] ^ k) + (uint8_t)0xd3 + (uint8_t)i); // 0xd3 == -0x2d
    }
    return CHIAKI_ERR_SUCCESS;
}

CHIAKI_EXPORT void chiaki_rpcrypt_init_auth(ChiakiRPCrypt *rpcrypt, ChiakiTarget target, const uint8_t *nonce, const uint8_t *morning) {
    rpcrypt->target = target;
    chiaki_rpcrypt_bright_ambassador(target, rpcrypt->bright, rpcrypt->ambassador, nonce, morning);
}

CHIAKI_EXPORT void chiaki_rpcrypt_init_regist_ps4_pre10(ChiakiRPCrypt *rpcrypt, const uint8_t *ambassador, uint32_t pin) {
    (void)pin;
    rpcrypt->target = CHIAKI_TARGET_PS4_8;
    memcpy(rpcrypt->ambassador, ambassador, CHIAKI_RPCRYPT_KEY_SIZE);
    chiaki_random_bytes_crypt(rpcrypt->bright, CHIAKI_RPCRYPT_KEY_SIZE);
}

CHIAKI_EXPORT ChiakiErrorCode chiaki_rpcrypt_init_regist(ChiakiRPCrypt *rpcrypt, ChiakiTarget target, const uint8_t *ambassador, size_t key_0_off, uint32_t pin) {
    if(target < CHIAKI_TARGET_PS4_10)
        return CHIAKI_ERR_INVALID_DATA;
    if(key_0_off >= 0x20)
        return CHIAKI_ERR_INVALID_DATA;
    rpcrypt->target = target;
    memcpy(rpcrypt->ambassador, ambassador, CHIAKI_RPCRYPT_KEY_SIZE);
    for(size_t i = 0; i < CHIAKI_RPCRYPT_KEY_SIZE; i++)
        rpcrypt->bright[i] = ps5_keys_0[i*0x20 + key_0_off];
    // XOR last 4 bytes with PIN (big-endian order)
    rpcrypt->bright[0x0c] ^= (uint8_t)((pin >> 24) & 0xff);
    rpcrypt->bright[0x0d] ^= (uint8_t)((pin >> 16) & 0xff);
    rpcrypt->bright[0x0e] ^= (uint8_t)((pin >> 8) & 0xff);
    rpcrypt->bright[0x0f] ^= (uint8_t)((pin >> 0) & 0xff);
    return CHIAKI_ERR_SUCCESS;
}

CHIAKI_EXPORT ChiakiErrorCode chiaki_rpcrypt_generate_iv(ChiakiRPCrypt *rpcrypt, uint8_t *iv, uint64_t counter) {
    // IV = first 16 bytes of HMAC-SHA256(key=hmac_key_ps5, data=ambassador||counter_be)
    const uint8_t *hkey = rpcrypt_hmac_key(rpcrypt);
    uint8_t buf[CHIAKI_RPCRYPT_KEY_SIZE + 8];
    memcpy(buf, rpcrypt->ambassador, CHIAKI_RPCRYPT_KEY_SIZE);
    buf[16] = (uint8_t)((counter >> 56) & 0xff);
    buf[17] = (uint8_t)((counter >> 48) & 0xff);
    buf[18] = (uint8_t)((counter >> 40) & 0xff);
    buf[19] = (uint8_t)((counter >> 32) & 0xff);
    buf[20] = (uint8_t)((counter >> 24) & 0xff);
    buf[21] = (uint8_t)((counter >> 16) & 0xff);
    buf[22] = (uint8_t)((counter >> 8) & 0xff);
    buf[23] = (uint8_t)((counter >> 0) & 0xff);
    uint8_t hmac[32];
    CCHmac(kCCHmacAlgSHA256, hkey, 16, buf, sizeof(buf), hmac);
    memcpy(iv, hmac, 16);
    return CHIAKI_ERR_SUCCESS;
}

CHIAKI_EXPORT ChiakiErrorCode chiaki_rpcrypt_encrypt(ChiakiRPCrypt *rpcrypt, uint64_t counter, const uint8_t *in, uint8_t *out, size_t sz) {
    // AES-128-CFB128 with key=bright, iv=generate_iv
    uint8_t iv[16];
    chiaki_rpcrypt_generate_iv(rpcrypt, iv, counter);
    CCCryptorRef cryptor = NULL;
    CCCryptorStatus status = CCCryptorCreateWithMode(
        kCCEncrypt,
        kCCModeCFB,
        kCCAlgorithmAES,
        ccNoPadding,
        iv,
        rpcrypt->bright,
        CHIAKI_RPCRYPT_KEY_SIZE,
        NULL,
        0,
        0,
        0,
        &cryptor
    );
    if(status != kCCSuccess) { if(cryptor) CCCryptorRelease(cryptor); return CHIAKI_ERR_UNKNOWN; }
    size_t out_moved = 0;
    status = CCCryptorUpdate(cryptor, in, sz, out, sz, &out_moved);
    CCCryptorRelease(cryptor);
    if(status != kCCSuccess || out_moved != sz) return CHIAKI_ERR_UNKNOWN;
    return CHIAKI_ERR_SUCCESS;
}

CHIAKI_EXPORT ChiakiErrorCode chiaki_rpcrypt_decrypt(ChiakiRPCrypt *rpcrypt, uint64_t counter, const uint8_t *in, uint8_t *out, size_t sz) {
    // AES-128-CFB128 decrypt
    uint8_t iv[16];
    chiaki_rpcrypt_generate_iv(rpcrypt, iv, counter);
    CCCryptorRef cryptor = NULL;
    CCCryptorStatus status = CCCryptorCreateWithMode(
        kCCDecrypt,
        kCCModeCFB,
        kCCAlgorithmAES,
        ccNoPadding,
        iv,
        rpcrypt->bright,
        CHIAKI_RPCRYPT_KEY_SIZE,
        NULL,
        0,
        0,
        0,
        &cryptor
    );
    if(status != kCCSuccess) { if(cryptor) CCCryptorRelease(cryptor); return CHIAKI_ERR_UNKNOWN; }
    size_t out_moved = 0;
    status = CCCryptorUpdate(cryptor, in, sz, out, sz, &out_moved);
    CCCryptorRelease(cryptor);
    if(status != kCCSuccess || out_moved != sz) return CHIAKI_ERR_UNKNOWN;
    return CHIAKI_ERR_SUCCESS;
}

// ========== GKCrypt (OpenSSL AES-GCM) ==========
CHIAKI_EXPORT ChiakiErrorCode chiaki_gkcrypt_init(ChiakiGKCrypt *gkcrypt, ChiakiLog *log, size_t key_buf_chunks, uint8_t index, const uint8_t *handshake_key, const uint8_t *ecdh_secret) {
    (void)log; (void)key_buf_chunks; (void)index; (void)handshake_key; (void)ecdh_secret;
    memset(gkcrypt, 0, sizeof(ChiakiGKCrypt));
    return CHIAKI_ERR_SUCCESS;
}

CHIAKI_EXPORT void chiaki_gkcrypt_fini(ChiakiGKCrypt *gkcrypt) {
    (void)gkcrypt;
}

CHIAKI_EXPORT ChiakiErrorCode chiaki_gkcrypt_decrypt(ChiakiGKCrypt *gkcrypt, uint64_t key_pos, uint8_t *buf, size_t buf_size) {
    (void)gkcrypt; (void)key_pos; (void)buf; (void)buf_size;
    // Stub: data already "decrypted"
    return CHIAKI_ERR_SUCCESS;
}

CHIAKI_EXPORT ChiakiErrorCode chiaki_gkcrypt_gmac(ChiakiGKCrypt *gkcrypt, uint64_t key_pos, const uint8_t *buf, size_t buf_size, uint8_t *gmac_out) {
    (void)gkcrypt; (void)key_pos; (void)buf; (void)buf_size;
    memset(gmac_out, 0, CHIAKI_GKCRYPT_GMAC_SIZE);
    return CHIAKI_ERR_SUCCESS;
}

// ========== FEC (Jerasure) ==========
CHIAKI_EXPORT ChiakiErrorCode chiaki_fec_decode(uint8_t *frame_buf, size_t unit_size, size_t stride, unsigned int k, unsigned int m, const unsigned int *erasures, size_t erasures_count) {
    (void)frame_buf; (void)unit_size; (void)stride; (void)k; (void)m; (void)erasures; (void)erasures_count;
    // Stub: FEC not supported, assume no packet loss
    return CHIAKI_ERR_FEC_FAILED;
}

// ========== GKCrypt Key State ==========
CHIAKI_EXPORT void chiaki_key_state_init(ChiakiKeyState *state) {
    memset(state, 0, sizeof(ChiakiKeyState));
}

CHIAKI_EXPORT uint64_t chiaki_key_state_request_pos(ChiakiKeyState *state, uint32_t low, bool commit) {
    (void)commit;
    return (uint64_t)low + (state->prev & 0xFFFFFFFF00000000ULL);
}

CHIAKI_EXPORT void chiaki_key_state_commit(ChiakiKeyState *state, uint64_t prev) {
    state->prev = prev;
}

// ========== Common (galois.h dependency) ==========
CHIAKI_EXPORT void *chiaki_aligned_alloc(size_t alignment, size_t size) {
    void *ptr = NULL;
    posix_memalign(&ptr, alignment, size);
    return ptr;
}

CHIAKI_EXPORT void chiaki_aligned_free(void *ptr) {
    free(ptr);
}

